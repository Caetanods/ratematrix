##' Perform posterior predictive simulations.
##'
##' This function performs posterior predictive simulations by sampling 'n.samples' times from the joint posterior distribution and creating a new dataset for each sample. The simulations can be used to check if the model and parameter estimates can generate data that is close to your data. This is a measure of model adequacy.
##' @title Make posterior predictive simulations.
##' @param mcmc.chain The posterior chain generated by 'read.single.R.iwish', 'read.multi.R.iwish', or 'mergePosterior'.
##' @param out The 'out' file from the MCMC function.
##' @param n.samples Number of samples to be taken from the posterior distribution.
##' @param mc.cores The number of cores to be used for parallel simulations. Default value is 'NULL' and uses a single computer processor.
##' @return A list of matrices. Each element is a simulation of datasets. Using the same model and parameter estimates from the joint posterior distribution.
##' @export
##' @seealso \code{read.single.R.iwish} or \code{read.multi.R.iwish} or \code{mergePosterior}
##' @importFrom phytools sim.corrs
postPredicSims <- function(mcmc.chain, out, n.samples=100, mc.cores=NULL){
    lchain <- dim(mcmc.chain$root)[1]
    ss <- sample(1:lchain, size = n.samples) ## Take samples from the (joint) posterior.

    root <- mcmc.chain$root[ss]
    
    if( out$p == 1 ){
        R <- mcmc.chain$matrix[ss]
    } else {
        R <- list()
        for(i in ss){
            R[[i]] <- lapply(1:out$p, function(x) mcmc.chain$matrix[[x]][[i]] )
            names(R[[i]]) <- colnames(out$phy$mapped.edge)
        }
    }
    if( is.null(mc.cores) ){
        sim.data <- lapply(1:length(ss), function(x) sim.corrs(tree = out$phy, vcv = R[[x]], anc = root[x,]) )
    } else {
        if( is.numeric(mc.cores) ){
            library(parallel)
            sim.data <- mclapply(1:length(ss), function(x) sim.corrs(tree = out$phy, vcv = R[[x]], anc = root[x,])
                               , mc.cores=mc.cores )
        } else {
            stop("mc.cores needs to be NULL or the number of cores to be used for 'mclapply'")
        }
    }

    return(sim.data)
}
