##' Make a grid plot with the posterior distribution of the evolutionary rate matrix (R). Function works with one or two matrices fitted to the same tree and will superpose the results.
##'
##' The upper-tri plots are the posterior density for the off-diagonal elements of the
##'     R evolutionary matrix. The diagonal plots are the posterior elements of the evolutionary
##'     rates for each of the traits. The lower-tri plots are ellipse plots for the rates of correlated
##'     evolution.\cr
##' \cr
##' Two posterior distributions of matrices can be plotted in the same grid if a distribution for
##'     'mat2' is also provided (optional). Otherwise only 'mat1' is plotted.\cr
##' \cr
##' If a second distribution of matrices is provided ('mat2') the function will check whether the number
##'      of matrices in each list is the same. If not, the first elements of the lengthier list will be pruned
##'      to match the length of the shorter list.\cr
##' \cr
##' Function use 'par()' to set graphical parameters. It may take some time to create all the plots if
##'      the number of traits is large. Thinning the posterior distribution of matrices before plotting is
##'      recommended.
##' @title Plot posterior distribution of rate matrices.
##' @param mat1 list. The posterior distribution of the R matrix.
##' @param mat2 list. The posterior distribution of the R matrix to be plotted with 'mat1'.
##' @param mle1 matrix. Used as a point estimate. Will be plotted as a vertical line or a single ellipse. Color is 'red'.
##' @param mle2 matrix. Same as 'mle2'. Can be used as the point estimate for 'mat2'.
##' @param colDiag1 string. Color for the diagonal of the grid plot and the lines of the lower-tri ellipses.
##' @param colDiag2 string. Same as 'colDiag1'. Can be used to set color of the 'mat2' plots.
##' @param alphaOff1 numeric. Transparency of the off-diagonal plots. Value between 0 and 1.
##' @param alphaOff2 numeric. Same as 'alphaOff1'. Set the transparency of the plots relative of 'mat2'.
##' @param leg string. Legend for the traits. Vector need to have length equal to the dimension of the R matrix.
##' @param l.cex numeric. 'cex' parameter for 'leg'. See 'help(par)' for more information on 'cex'.
##' @param hpd numeric. Set the proportion of the highest posterior density (HPD) to be highlighted in the plot. If set .95 the distributions and the ellipses within the 95% HPD will be highlighted in the plot. Default value does not show highlighted region.
##' @param show.zero logical. Whether to plot a 'blue' vertical line at 0.
##' @param set.xlim numeric. Two elements vector to set the 'xlim' [see 'help(hist)'] for the density plots manually. If 'NULL', the default value, then the limits are calculated from the data.
##' @param n.lines numeric. Number of lines to be displayed in the ellipsed plots.
##' @return Plot a grid of charts.
##' @author Daniel S. Caetano, \email{caetanods1@@gmail.com}
make.grid.plot <- function(mat1, mat2=NULL, mle1=NULL, mle2=NULL, colDiag1="purple", colDiag2="green", alphaOff1=0.5, alphaOff2=0.5, leg=NULL, l.cex=0.7, hpd=100, show.zero=FALSE, set.xlim=NULL, n.lines=50){
    ## Make a grid plot. The upper-tri is the posterior density for the off-diagonal elements of the
    ##     R evolutionary matrix. The diagonal plots are the posterior elements of the evolutionary
    ##     rates for each of the traits. The lower-tri are ellipse plots for the rates of correlated
    ##     evolution.
    ## Two posterior distributions of matrices can be plotted in the same grid if a distribution for the
    ##     'mat2' argument is provided. Otherwise only mat1 is plotted.
    ## If a second distribution of matrices is provided the code will check whether the number of matrices
    ##     in each list is the same. If not the shorter length will be used and x matrices will be dropped
    ##     from the beginning of the respective distribution. 
    ## mat1 = a list of the posterior for the R matrix to be plotted.
    ## mat2 = a list of the posterior for the R matrix to be plotted. Optional.
    ## mle1 = a matrix object. This is plotted as a point estimate in the grid plot. The color is always "red".
    ##     Argument is optional.
    ## mle1 = a matrix object. This is plotted as a point estimate in the grid plot. The color is always "red".
    ##     Argument is optional.    
    ## colDiag1 = color for the diagonal of the grid plot. Color also be used to plot the lines of the ellipse
    ##     plots. Takes the same colors as in "adjustcolor" function.
    ## colDiag2 = color for the diagonal of the grid plot. Color also be used to plot the lines of the ellipse
    ##     plots. Takes the same colors as in "adjustcolor" function. Optional.
    ## alphaOff1 = The transparency for the color in the off-diagonals. Numeric from 0 - 1.
    ## alphaOff2 = The transparency for the color in the off-diagonals. Numeric from 0 - 1.
    ## leg = a character string with length equal to the number of rows in mat.
    ## l.cex = the cex parameter for the 'leg'.
    ## hpd = numeric value from 1 to 100. The percentage of the Highest Posterior Density to be highlighted
    ##     in the plots. By default the function plots the whole posterior.
    ## show.zero = logical. Whether to plot a vertical line in blue showing the zero position in the
    ##     density plots.
    ## set.xlim = Set the xlim for the density plots manually. If NULL then the limits are calculated
    ##     from the data. Need to be a two element vector, such as 'xlim'.
    ## n.lines = Number of lines to be displayed in the ellipse plots.

    ## Check if matrix 2 is provided and make some data checking.
    if( !is.null(mat2) ){
        if( !is.list(mat2) ){
            stop("Argument 'mat2' need to be of class list.")
        } else{
            dd1 <- dim(mat1[[1]])[1]
            dd2 <- dim(mat2[[1]])[1]
            if( !dd1 == dd2 ){
                stop("Distributions of matrices to be plotted need to have the same number of dimensions.")
            }else{}
        }
    } else{}

    ll <- length(mat1) ## This should be the same for both matrices lists.
    dd <- dim(mat1[[1]])[1]

    ## Create default titles:
    if(is.null(leg)){
        leg <- paste("trait_", 1:dd, sep="")
    }

    ########################################################################################
    ## BLOCK FOR HIGHLIGHT THE HPD:

    if(hpd < 100){
        ## Calculate the probabilities for the hpd:
        frac <- (1-(hpd/100))/2
        prob <- c(frac,1-frac)

        ## Create a list where each element is a line of the grid plot:
        LL1 <- lapply(1:dd, function(y) data.frame( t( sapply(mat1, function(x) x[y,] ) ) ) )
        if( !is.null(mat2) ){ LL2 <- lapply(1:dd, function(y) data.frame( t( sapply(mat2, function(x) x[y,] ) ) ) ) }

        ## Calculate the limits for the HPD for each cell in the matrix:
        qq1 <- list()
        qq.count <- 1
        for(i in 1:dd){
            for(j in i:dd){
                qq1[[qq.count]] <- quantile(x=LL1[[i]][,j], probs=prob)
                qq.count <- qq.count+1
            }
        }
        if( !is.null(mat2) ){
            qq2 <- list()
            qq.count <- 1
            for(i in 1:dd){
                for(j in i:dd){
                    qq2[[qq.count]] <- quantile(x=LL2[[i]][,j], probs=prob)
                    qq.count <- qq.count+1
                }
            }
        }

        ## Make Sample Of Matrices To The ellipse plots:
        ss <- sample(1:ll, size=n.lines)
        ss.mat1 <- mat1[ss]
        if( !is.null(mat2) ){ ss.mat2 <- mat2[ss] }
        
        ## Check whether the sampled matrices are inside or outside the hpd:
        ss.LL1 <- lapply(1:dd, function(y) data.frame( t( sapply(ss.mat1, function(x) x[y,] ) ) ) )
        if( !is.null(mat2) ){ ss.LL2 <- lapply(1:dd, function(y) data.frame( t( sapply(ss.mat2, function(x) x[y,] ) ) ) ) }

        inside1 <- t( sapply(ss.mat1, function(x) check.hpd(x, qq1, dd) ) )
        if(sum(inside1) == 0){
            stop( paste("All", n.lines," sampled matrices from mat1 are outside the", hpd, " HPD interval.") )
        }
        if( !is.null(mat2) ){
            inside2 <- t( sapply(ss.mat2, function(x) check.hpd(x, qq2, dd) ) )
            if(sum(inside2) == 0){
                stop( paste("All", n.lines," sampled matrices from mat2 are outside the", hpd, " HPD interval.") )
            }
        }            

        ## Get the data for the ellipse plots. The data is going to be in the same order of
        ##         the graphs in the par grid plot. Only the 'lower tri' part of the grid.
        ## Here i is the x axis and j is the y axis.
        ell.data.in1 <- list() ## Ellipses inside hpd
        ell.data.out1 <- list() ## Ellipses outside hpd        
        ell.data.count <- 1
        for(i in 2:dd){
            for(j in 1:(i-1)){
                ell.data.in1[[ell.data.count]] <- get.vcv.ellipse.all.matrix( mat=ss.mat1[inside1]
                                                                          , traits=c(i,j) )
                ell.data.out1[[ell.data.count]] <- get.vcv.ellipse.all.matrix( mat=ss.mat1[!inside1]
                                                                           , traits=c(i,j) )
                ell.data.count <- ell.data.count+1
            }
        }
        
        if( !is.null(mat2) ){
            ell.data.count <- 1
            ell.data.in2 <- list()
            ell.data.out2 <- list()
            for(i in 2:dd){
                for(j in 1:(i-1)){
                    ell.data.in2[[ell.data.count]] <- get.vcv.ellipse.all.matrix( mat=ss.mat2[inside2]
                                                                               , traits=c(i,j) )
                    ell.data.out2[[ell.data.count]] <- get.vcv.ellipse.all.matrix( mat=ss.mat2[!inside2]
                                                                                , traits=c(i,j) )
                    ell.data.count <- ell.data.count+1
                }
            }
        }

        ## Create ellipse for the MLE estimate.
        if( is.matrix(mle1) ){
            ell.mle1 <- list()
            ell.mle.count <- 1
            for(i in 2:dd){
                for(j in 1:(i-1)){
                    ell.mle1[[ell.mle.count]] <- get.vcv.ellipse.matrix( mat=mle1, traits=c(i,j) )
                    ell.mle.count <- ell.mle.count+1
                }
            }
        }
        
        if( is.matrix(mle2) ){
            ell.mle2 <- list()         
            ell.mle.count <- 1
            for(i in 2:dd){
                for(j in 1:(i-1)){
                    ell.mle2[[ell.mle.count]] <- get.vcv.ellipse.matrix( mat=mle2, traits=c(i,j) )
                    ell.mle.count <- ell.mle.count+1
                }
            }
        }

        ## Get the data for the histogram plots. Also in the same order as the plotting.
        ## Here using the data to calculate the range for the x and y axes.
        ## Here i is the x axis and j is the y axis.

        y.hist <- vector()
        x.hist <- vector()
        ## First need to find the xlim of the plots. Will need this quantity to set the breaks for
        ##      the histograms.
        for(i in 1:dd){
            for(j in i:dd){
                x.hist <- c( min(x.hist[1], LL1[[i]][,j], na.rm=TRUE) , max(x.hist[2], LL1[[i]][,j], na.rm=TRUE) )
            }
        }
        if( !is.null(mat2) ){
            ## If the mat2 is provided, them check wether the limits need to be modified.
            ## Note that it follows the same structure as the previous one.
            for(i in 1:dd){
                for(j in i:dd){
                    x.hist <- c( min(x.hist[1], LL2[[i]][,j], na.rm=TRUE) , max(x.hist[2], LL2[[i]][,j], na.rm=TRUE) )
                }
            }
        }
        
        if(is.null(set.xlim)){
            ## Calculate the window of each bar:
            wd <- (x.hist[2] - mean(x.hist))/20
            ## Make a sequence for the breaks. Note that we add one window (bar) to the borders.
            brk <- seq(from=x.hist[1]-wd, to=x.hist[2]+wd, by=wd)
            xlim.hist <- x.hist
        } else{
            wd <- (set.xlim[2] - mean(set.xlim))/20
            brk <- seq(from=x.hist[1]-wd, to=x.hist[2]+wd, by=wd)
            xlim.hist <- set.xlim
        }

        hists1 <- list()
        ccat1 <- list()
        hists2 <- list()
        ccat2 <- list()
        hist.count <- 1
        for(i in 1:dd[1]){
            for(j in i:dd[1]){
                ## Remember that the list 'LL' were made over the lines of the grid.
                ## This is to calculate the x and y limits of the histogram.
                hists1[[hist.count]] <- hist(LL1[[i]][,j], plot=FALSE, breaks=brk) ## This might break because the brk are from the two plots.
                if( !is.null(mat2) ){ hists2[[hist.count]] <- hist(LL2[[i]][,j], plot=FALSE, breaks=brk) }
                ## Create the cuts for the hpd:
                ccat1[[hist.count]] <- cut(hists1[[hist.count]]$breaks
                                        , c(-Inf, qq1[[hist.count]][1], qq1[[hist.count]][2], Inf))             
                y.hist <- max(y.hist, hists1[[hist.count]]$density)
                if( !is.null(mat2) ){
                    ccat2[[hist.count]] <- cut(hists2[[hist.count]]$breaks
                                            , c(-Inf, qq2[[hist.count]][1], qq2[[hist.count]][2], Inf))
                    y.hist <- max(y.hist, hists2[[hist.count]]$density)
                }
                hist.count <- hist.count+1
            }
        }
        ylim.hist <- c(0,y.hist)

        ## Get the xlim and ylim for ellipse plots:
        ## This is just like the original case. But here the function will take into account the limits of both
        ##       mat1 and mat2 in the case that the user have two matrices.

        ## First a block for the case with one matrix, then a block for the single case:
        if( is.null(mat2) ){
            ell.lim.in <- lapply(ell.data.in1, function(x) x[[1]])
            ell.lim.in <- do.call(rbind, ell.lim.in)
            ell.lim.in <- apply(ell.lim.in, 2, range)
            ell.lim.out <- lapply(ell.data.out1, function(x) x[[1]])
            ell.lim.out <- do.call(rbind, ell.lim.out)
            ell.lim.out <- apply(ell.lim.out, 2, range)
            ell.lim <- rbind(ell.lim.out, ell.lim.in)
            ell.lim <- apply(ell.lim, 2, range)
        } else{
            ell.lim.in <- lapply( c(ell.data.in1, ell.data.in2) , function(x) x[[1]])
            ell.lim.in <- do.call(rbind, ell.lim.in)
            ell.lim.in <- apply(ell.lim.in, 2, range)
            ell.lim.out <- lapply( c(ell.data.out1, ell.data.out1) , function(x) x[[1]])
            ell.lim.out <- do.call(rbind, ell.lim.out)
            ell.lim.out <- apply(ell.lim.out, 2, range)
            ell.lim <- rbind(ell.lim.out, ell.lim.in)
            ell.lim <- apply(ell.lim, 2, range)
        }
        
        ## Save the original par:
        old.par <- par(no.readonly = TRUE)

        ## Set par block:
        par(mfrow = c(dd, dd))
        par(cex = 0.6)
        par(mar = c(0, 0, 0, 0), oma = c(2, 2, 2, 2))
        par(tcl = -0.25)
        par(mgp = c(2, 0.6, 0))
        ## par(xpd = NA) ## To make plots outside plotting area.

        ## Plot the graphs in the grid:
        ## The if and else make sure that the upper.tri and the lower.tri get the correct plots.
        ## Both the ellipse lines and the densities for the diagonal and off-diagonal elements
        ##     are in lists objects with the same order of the plots in the grid. Then at each
        ##     plot the function will call the next element of the correspondent list.
        ## The ell and dens.plot.count are here to help to call the correct data to put in each plot.

        ## Produce some of the colors.
        ## Need to create the off-diagonal colors based on the alpha for the colors in the diagonal.
        colOff1 <- adjustcolor(col=colDiag1, alpha.f=alphaOff1)
        colOff2 <- adjustcolor(col=colDiag2, alpha.f=alphaOff2)

        ell.plot.count <- 1
        hist.plot.count <- 1
        for(i in 1:dd){
            for(j in 1:dd){
                if(j >= i){
                    plot(1, xlim=xlim.hist, ylim=ylim.hist, axes=FALSE, type="n", xlab="", ylab="")
                    mid <- mean(xlim.hist)
                    first.quart <- xlim.hist[1] + (mid - xlim.hist[1])/2
                    second.quart <- mid + (xlim.hist[2] - mid)/2
                    lines(x=c(mid,mid), y=ylim.hist, type="l", lty = 3, col="grey")
                    lines(x=c(first.quart, first.quart), y=ylim.hist, type="l", lty = 3, col="grey")
                    lines(x=c(second.quart, second.quart), y=ylim.hist, type="l", lty = 3, col="grey")
                    if(show.zero == TRUE){
                        lines(x=c(0,0), y=ylim.hist, type="l", lty = 3, col="blue")
                    }
                    box(col="grey")
                    if(j != i){
                        plot(hists1[[hist.plot.count]], add=TRUE, freq=FALSE, border="gray"
                           , col=c("white",colOff1,"white")[ccat1[[hist.plot.count]]] )
                        if( !is.null(mat2) ) {
                            plot(hists2[[hist.plot.count]], add=TRUE, freq=FALSE, border="gray"
                                                    , col=c("white",colOff2,"white")[ccat2[[hist.plot.count]]] ) }
                    } else{
                        plot(hists1[[hist.plot.count]], add=TRUE, freq=FALSE, border="black"
                           , col=c("white",colDiag1,"white")[ccat1[[hist.plot.count]]] )
                        if( !is.null(mat2) ){
                            plot(hists2[[hist.plot.count]], add=TRUE, freq=FALSE, border="black"
                               , col=c("white",colDiag2,"white")[ccat2[[hist.plot.count]]] )
                        }
                        if(i == dd[1]){
                            axis(1, at=round(c(xlim.hist[1],mean(xlim.hist),xlim.hist[2]), digits = 2) )
                        }
                    }
                    if(i == 1){
                        mtext(text=leg[j], side=3, cex=l.cex)
                    }
                    if(j == 1){
                        mtext(text=leg[i], side=2, cex=l.cex)
                    }
                    if(is.matrix(mle1)){
                        lines(x=c(mle1[i,j],mle1[i,j]), y=ylim.hist, type="l", col="red")
                    }
                    if(is.matrix(mle2)){
                        lines(x=c(mle2[i,j],mle2[i,j]), y=ylim.hist, type="l", col="red")
                    }
                    hist.plot.count <- hist.plot.count+1
                } else{
                    plot(1, xlim=ell.lim[,1], ylim=ell.lim[,2], axes=FALSE, type="n", xlab="", ylab="")
                    box(col="grey")
                    invisible( lapply(ell.data.out1[[ell.plot.count]][[2]], points, col = colOff1
                                    , type = "l", lwd = 0.5) )
                    invisible( lapply(ell.data.in1[[ell.plot.count]][[2]], points, col = colDiag1
                                    , type = "l", lwd = 0.5) )
                    if( !is.null(mat2) ){
                        invisible( lapply(ell.data.out2[[ell.plot.count]][[2]], points, col = colOff2
                                        , type = "l", lwd = 0.5) )
                        invisible( lapply(ell.data.in2[[ell.plot.count]][[2]], points, col = colDiag2
                                        , type = "l", lwd = 0.5) )
                    }
                    if( is.matrix(mle1) ){
                        invisible( points(ell.mle1[[ell.plot.count]], col="red", type="l", lwd=0.5) )
                    }
                    if( is.matrix(mle2) ){                        
                        invisible( points(ell.mle2[[ell.plot.count]], col="red", type="l", lwd=0.5) )
                    }
                    ell.plot.count <- ell.plot.count+1
                    if(j == 1){
                        mtext(text=leg[i], side=2, cex=l.cex)
                    }
                }            
            }
        }
        ## Return the old parameters:
        par(old.par)
    } else{

        ########################################################################################
        ## BLOCK FOR POSTERIOR HPD IS NOT HIGHLIGHTED.
        ## This is used when hpd == 100.
        
        ## Create a list where each element is a line of the grid plot:
        LL1 <- lapply(1:dd, function(y) data.frame( t( sapply(mat1, function(x) x[y,] ) ) ) )
        if( !is.null(mat2) ){ LL2 <- lapply(1:dd, function(y) data.frame( t( sapply(mat2, function(x) x[y,] ) ) ) ) }

        ## Get the data for the ellipse plots. The data is going to be in the same order of
        ##         the graphs in the par grid plot. Only the 'lower tri' part of the grid.
        ## Here i is the x axis and j is the y axis.
        ell.data1 <- list()
        ell.data.count <- 1    
        for(i in 2:dd){
            for(j in 1:(i-1)){
                ell.data1[[ell.data.count]] <- get.vcv.ellipse.matrix(mat=mat1, traits=c(i,j) )
                ell.data.count <- ell.data.count+1
            }
        }
        
        if( !is.null(mat2) ){
            ell.data.count <- 1
            ell.data2 <- list()
            for(i in 2:dd){
                for(j in 1:(i-1)){
                    ell.data2[[ell.data.count]] <- get.vcv.ellipse.matrix(mat=mat2, traits=c(i,j) )
                    ell.data.count <- ell.data.count+1
                }
            }
        }
        
        ## Create ellipse for the MLE estimate.
        if( is.matrix(mle1) ){
            ell.mle1 <- list()
            ell.mle.count <- 1
            for(i in 2:dd){
                for(j in 1:(i-1)){
                    ell.mle1[[ell.mle.count]] <- get.vcv.ellipse.matrix( mat=mle1, traits=c(i,j) )
                    ell.mle.count <- ell.mle.count+1
                }
            }
        }
        if( is.matrix(mle2) ){            
            ell.mle2 <- list()
            ell.mle.count <- 1
            for(i in 2:dd){
                for(j in 1:(i-1)){
                    ell.mle2[[ell.mle.count]] <- get.vcv.ellipse.matrix( mat=mle2, traits=c(i,j) )
                    ell.mle.count <- ell.mle.count+1
                }
            }
        }

        ## Get the data for the histogram plots. Also in the same order as the plotting.
        ## Here using the data to calculate the range for the x and y axes.
        
        y.hist <- vector()
        x.hist <- vector()
        ## First need to find the xlim of the plots. Will need this quantity to set the breaks for
        ##      the histograms.
        for(i in 1:dd){
            for(j in i:dd){
                x.hist <- c( min(x.hist[1], LL1[[i]][,j], na.rm=TRUE) , max(x.hist[2], LL1[[i]][,j], na.rm=TRUE) )
            }
        }
        if( !is.null(mat2) ){
            ## If the mat2 is provided, them check wether the limits need to be modified.
            ## Note that it follows the same structure as the previous one.
            for(i in 1:dd){
                for(j in i:dd){
                    x.hist <- c( min(x.hist[1], LL2[[i]][,j], na.rm=TRUE) , max(x.hist[2], LL2[[i]][,j], na.rm=TRUE) )
                }
            }
        }
        
        if(is.null(set.xlim)){
            ## Calculate the window of each bar:
            wd <- (x.hist[2] - mean(x.hist))/20
            ## Make a sequence for the breaks. Note that we add one window to the borders.
            brk <- seq(from=x.hist[1]-wd, to=x.hist[2]+wd, by=wd)
            xlim.hist <- x.hist
        } else{
            wd <- (set.xlim[2] - mean(set.xlim))/20
            brk <- seq(from=x.hist[1]-wd, to=x.hist[2]+wd, by=wd)
            xlim.hist <- set.xlim
        }

        hists1 <- list()
        hists2 <- list()
        hist.count <- 1
        for(i in 1:dd){
            for(j in i:dd){
                ## Remember that the list 'LL' where made over the lines of the grid.
                ## This is to calculate the x and y limits of the histogram.
                hists1[[hist.count]] <- hist(LL1[[i]][,j], plot=FALSE, breaks=brk)
                y.hist <- max(y.hist, hists1[[hist.count]]$density)
                if( !is.null(mat2) ){
                    hists2[[hist.count]] <- hist(LL2[[i]][,j], plot=FALSE, breaks=brk)
                    y.hist <- max(y.hist, hists2[[hist.count]]$density)
                }
                hist.count <- hist.count + 1
            }
        }
        ylim.hist <- c(0,y.hist)

        ## Get the xlim and ylim for ellipse plots:
        if( !is.null(mat2) ){
            ell.lim <- lapply( c(ell.data1, ell.data2) , function(x) x[[1]])
            ell.lim <- do.call(rbind, ell.lim)
            ell.lim <- apply(ell.lim, 2, range)
        } else{
            ell.lim <- lapply(ell.data1, function(x) x[[1]])
            ell.lim <- do.call(rbind, ell.lim)
            ell.lim <- apply(ell.lim, 2, range)
        }
        
        ## Save the original par:
        old.par <- par(no.readonly = TRUE)

        ## Set par block:
        par(mfrow = c(dd[1], dd[1]))
        par(cex = 0.6)
        par(mar = c(0, 0, 0, 0), oma = c(2, 2, 2, 2))
        par(tcl = -0.25)
        par(mgp = c(2, 0.6, 0))
        ## par(xpd = NA) ## To make plots outside plotting area.

        ## Create the color for the plot:
        colOff1 <- adjustcolor(col=colDiag1, alpha.f=alphaOff1)
        colOff2 <- adjustcolor(col=colDiag2, alpha.f=alphaOff2)

        ## Plot the graphs in the grid:
        ## The if and else make sure that the upper.tri and the lower.tri get the correct plots.
        ## Both the ellipse lines and the densities for the diagonal and off-diagonal elements
        ##     are in lists objects with the same order of the plots in the grid. Then at each
        ##     plot the function will call the next element of the correspondent list.
        ## The ell and dens.plot.count are here to help to call the correct data to put in each plot.
        
        ell.plot.count <- 1
        hist.plot.count <- 1
        for(i in 1:dd){
            for(j in 1:dd){
                if(j >= i){
                    plot(1, xlim=xlim.hist, ylim=ylim.hist, axes=FALSE, type="n", xlab="", ylab="")
                    mid <- mean(xlim.hist)
                    first.quart <- xlim.hist[1] + (mid - xlim.hist[1])/2
                    second.quart <- mid + (xlim.hist[2] - mid)/2
                    lines(x=c(mid,mid), y=ylim.hist, type="l", lty = 3, col="grey")
                    lines(x=c(first.quart, first.quart), y=ylim.hist, type="l", lty = 3, col="grey")
                    lines(x=c(second.quart, second.quart), y=ylim.hist, type="l", lty = 3, col="grey")
                    if(show.zero == TRUE){
                        lines(x=c(0,0), y=ylim.hist, type="l", lty = 3, col="blue")
                    }
                    box(col="grey")
                    if(j != i){
                        plot(hists1[[hist.plot.count]], add=TRUE, freq=FALSE, col=colOff1, border="gray")
                        if( !is.null(mat2) ){ plot(hists2[[hist.plot.count]], add=TRUE, freq=FALSE, col=colOff2, border="gray") }
                    } else{
                        plot(hists1[[hist.plot.count]], add=TRUE, freq=FALSE, col=colDiag1, border="black")
                        if( !is.null(mat2) ){ plot(hists2[[hist.plot.count]], add=TRUE, freq=FALSE, col=colDiag2, border="black") }
                        if(i == dd){ axis(1, at=round(c(xlim.hist[1],mean(xlim.hist),xlim.hist[2]), digits = 2) ) }
                    }
                    if(i == 1){
                        mtext(text=leg[j], side=3, cex=l.cex)
                    }
                    if(j == 1){
                        mtext(text=leg[i], side=2, cex=l.cex)
                    }
                    if(is.matrix(mle1)){
                        lines(x=c(mle1[i,j],mle1[i,j]), y=ylim.hist, type="l", col="red")
                    }
                    if(is.matrix(mle2)){
                        lines(x=c(mle2[i,j],mle2[i,j]), y=ylim.hist, type="l", col="red")
                    }
                    hist.plot.count <- hist.plot.count + 1
                } else{
                    plot(1, xlim=ell.lim[,1], ylim=ell.lim[,2], axes=FALSE, type="n", xlab="", ylab="")
                    box(col="grey")
                    invisible( lapply(ell.data1[[ell.plot.count]][[2]], points, col = colDiag1
                                    , type = "l", lwd = 0.5) )
                    if( !is.null(mat2) ){
                        invisible( lapply(ell.data2[[ell.plot.count]][[2]], points, col = colDiag2
                                        , type = "l", lwd = 0.5) )
                    }
                    if( is.matrix(mle1) ){
                        invisible( points(ell.mle1[[ell.plot.count]], col="red", type="l", lwd=0.5) )
                    }
                    if( is.matrix(mle2) ){
                        invisible( points(ell.mle2[[ell.plot.count]], col="red", type="l", lwd=0.5) )
                    }
                    ell.plot.count <- ell.plot.count+1
                    if(j == 1){
                        mtext(text=leg[i], side=2, cex=l.cex)
                    }
                }            
            }
        }
        ## Return the old parameters:
        par(old.par)
    }
}
