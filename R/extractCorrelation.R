##' Function extracts the posterior distribution of evolutionary correlation among traits.
##'
##' Returns a list with length equal to the number of regimes. Each list element is composed by a matrix with trait correlation types in the columns and the evolutionary correlations for each sample at the rows. \cr
##' \cr
##' One can plot the correlation values using boxplots and compare their distribution. Pairwise statistical tests across the samples is also possible.
##' @title Extract the posterior distribution of evolutionary correlation
##' @param post a posterior distribution object as returned by the function 'readMCMC' or a merged posterior generated by 'mergePosterior'.
##' @param traits optional character vector with the names for the traits.
##' @return a list with the posterior distribution of evolutionary correlations among traits.
##' @author Daniel Caetano and Luke Harmon
##' @export
##' @examples
##' \donttest{
##' data( centrarchidae )
##' dt.range <- t( apply( centrarchidae$data, 2, range ) )
##' ## The step size for the root value can be set given the range we need to sample from:
##' w_mu <- ( dt.range[,2] - dt.range[,1] ) / 10
##' par.sd <- cbind(c(0,0), sqrt( c(10,10) ))
##' prior <- makePrior(r=2, p=2, den.mu="unif", par.mu=dt.range, den.sd="unif", par.sd=par.sd)
##' handle <- ratematrixMCMC(data=centrarchidae$data, phy=centrarchidae$phy.map, prior=prior
##'                          , gen=10000, w_mu=w_mu, dir=tempdir())
##' posterior <- readMCMC(handle, burn = 0.2, thin = 10)
##' ## Get the correlations:
##' cor.list <- extractCorrelation(post = posterior)
##' ## Plot the results:
##' boxplot(cor.list[[1]], main = "Regime 1") ## Regime 1
##' boxplot(cor.list[[2]], main = "Regime 2") ## Regime 2
##' }
extractCorrelation <- function(post, traits=NULL){
    ## Check the class of the input.
    if( !inherits(post, what = c("ratematrix_multi_chain", "ratematrix_single_chain", "ratematrix_poly_chain") ) ) stop("Argument 'post' need to be a posterior distribution object. See 'readMCMC' help page.")

    ## Check the number of regimes:
    if( is.matrix( post$matrix[[1]] ) ){
        ## Single regime case.
        n.regimes <- 1
        ## Fix the object structure to run the rest of the function:
        tmp <- post$matrix
        post$matrix <- NULL
        post$matrix <- list( tmp )
    } else{
        ## Multiple regimes:
        n.regimes <- length( post$matrix )
        regime.names <- names( post$matrix )
    }
    cor.list <- lapply(1:n.regimes, function(x) lapply(post$matrix[[x]], cov2cor ) )
    n.samples <- length(cor.list[[1]])
    n.traits <- ncol( cor.list[[1]][[1]] )
    n.upper <- sum( upper.tri(cor.list[[1]][[1]]) )

    ## Create storage objects.
    out.list <- lapply(1:n.regimes, function(x) matrix(nrow = n.samples, ncol = n.upper) )
    upper.id <- matrix(nrow = n.upper, ncol = 2)
    upper.name <- vector("character", length = n.upper)

    ## Find the indexes for the upper triangular elements.
    ## Also generate informative names.
    ## Get some information from the data.
    if( is.null( traits ) ){
        if( !is.null( post$root ) ){
            traits <- colnames( post$root )
        } else{
            warning("Failed to find trait names.")
            traits <- paste0("trait_", 1:n.traits)
        }
    }

    count <- 1
    for( n.row in 1:n.traits ){
        for( n.col in 1:n.traits ){
            if( n.col > n.row ){
                upper.id[count,] <- c(n.row,n.col)
                upper.name[count] <- paste0(traits[n.col], "_x_", traits[n.row])
                count <- count + 1
            }
        }
    }

    ## Loop through the thing.
    for( regime in 1:n.regimes ){
        for( upper in 1:n.upper ){
            out.list[[regime]][,upper] <- sapply(1:n.samples, function(y) cor.list[[regime]][[y]][upper.id[upper,1],upper.id[upper,2]])
        }
        colnames( out.list[[regime]] ) <- upper.name
    }
    
    ## If the model has a single regime, then we need dummy names here:
    if( n.regimes > 1 ){
        names( out.list ) <- regime.names
    }

    ## Return a list-type object if more than one regime.
    if( n.regimes > 1 ){
        return( out.list )
    } else{
        return( out.list[[1]] )
    }
    
}
