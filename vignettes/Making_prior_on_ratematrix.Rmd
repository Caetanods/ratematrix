---
title: "Using prior distributions with 'ratematrix'"
author: "Daniel S. Caetano"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using prior distributions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Using prior distributions with 'ratematrix'

Here we are going to set uninformative and informative priors for each of the parameters of the model. This vignette will be divided into three sections, one for each parameter of the model. Please note that estimation is based on MCMC, so the analyses might take some time to run.

## Priors on the root value

The 'ratematrix' package estimates the root value and the evolutionary rate matrix for a multivariate Brownian-motion model. BM models have a property in which trait values for the nodes converge as we travel down from the tip to the root of the tree. The root value is going to be close to the mean of the tip data. Because of the properties of the model, we known a priori that the estimated root is not going to be outside the range of the observed tip values and likely close to the mean of the tip data.

It is important to note that this behavior is expected for the **estimated root value** regardless of the true root value. The BM model (as well as many other models of trait evolution) requires information at the nodes of the phylogeny (such as fossil data) for a more accurate estimate of the root value.

Load required packages:
```{r}
library( ratematrix )
library( geiger )
```

Simulate some data:
```{r}
phy <- sim.bdtree(b=1, d=0, stop="taxa", n=100)
R <- rbind(c(0.5, 0.2),
           c(0.2, 0.5) )
dat <- simRatematrix(tree=phy, vcv=R, anc=c(5,10))
```

Now we will run three analysis, with a uniform prior, with a normally distributed prior centered in the mean of the tip data and with another informative prior, but centered far from the mean of the tip data.

### Uniform prior on the root

Set analysis. Here we will use the `makePrior()` function.
```{r}
## Create a matrix with the bounds for the uniform prior. 
## Here will use the max and min of the tip data as bounds.
par.mu <- rbind( ceiling( range(dat[,1]) ), ceiling( range(dat[,2]) ) )
## Using a lognormal prior on the standard deviations, with log(mean)=0 and log(sd)=1.5.
par.sd <- c(0,1.5)
## Prior on the covariance matrix is set to the default: marginally uniform on the covariances.
unif.prior <- makePrior(r = 2, p = 1, den.mu = "unif", par.mu = par.mu, den.sd = "lnorm"
                        , par.sd = par.sd)
```

Now we are ready to run the MCMC analysis using the prior we created. Here I slightly increased the frequency that the chain is sampling the root values.
```{r, eval=FALSE}
handle.unif.root <- ratematrixMCMC(data=dat, phy=phy, prior=unif.prior, start="prior_sample"
                                   , gen=200000, outname="uniform_root_prior", prop=c(0.1,0.9) )
```
```{r, echo=FALSE}
load( system.file("extdata", "unif.root.RData", package = "ratematrix") )
```

This function will write files to the directory. The output is a handle object that stores the information of the MCMC run. The handle object will be required by other functions. The next code block will read the MCMC output from file and make a fast convergence analysis.
```{r, eval=2}
post.unif.root <- readMCMC(handle=handle.unif.root)
checkConvergence(post.unif.root)
```

This convergence analysis is only based on a single chain. Values of TRUE means that the chain passed the test. Please check the vignette about convergence for more details. Use function `browseVignettes("ratematrix")` for the list of vignettes.
Now we can plot the prior used for this analysis. Note that the prior is flat with the specified range.
```{r, fig.height=4, fig.width=6}
plotPrior(handle=handle.unif.root, root=TRUE)
```

Then we plot the posterior distribution of the root values. The red lines show the true parameter value used to simulate the data.
```{r, fig.height=4, fig.width=6}
plotRootValue(post.unif.root, vline.values = c(5,10), vline.color = c("red","red"))
```

Not bad! We can see that the posterior distribution of the root values include the true parameter values used for the simulations.


We can see that the posterior distribution is centered around the true parameter values for the simulation. This is expected since we simulated data under the model.

### Informative prior on the root

What if the prior on the root value is informative? The two most common reasons to want this is when a) we have external information of the trait value at the root or b) we want to inform the parameter values to help the analysis achieve convergence. The first case is a obvious case for the use of priors. Priors can be used to input information we have about a model before the analysis even start. The second case is more technical. The idea is that some parameters of a model can be hard to estimate, so we can use prior distributions to help stabilize such estimates. This is not the case here, the multivariate Normal model is usually well-behaved. Check work by Uyeda and Harmon (A Novel Bayesian Method for Inferring and Interpreting the Dynamics of Adaptive Landscapes from Phylogenetic Comparative Data, 2014, Systematic Biology) for an interesting example on the use of informative priors.

Here we are going to intentionally set a prior centered on values away from the true parameter values. Then we will explore the effect that this has on the analysis. First we generate the prior distribution, such steps are similar to what we did before:

```{r}
## Generate a matrix with the parameters for a normal distribution for the root values.
## Root_1: mean 0 and sd 1 and Root_2: mean 15 and sd 2.
par.mu <- rbind( c(0, 1), c(15, 2) )
## Using a lognormal prior on the standard deviations, with log(mean)=0 and log(sd)=1.5.
par.sd <- c(0, 1.5)
## Prior on the covariance matrix is set to the default: marginally uniform on the covariances.
norm.prior <- makePrior(r = 2, p = 1, den.mu = "norm", par.mu = par.mu, den.sd = "lnorm"
                        , par.sd = par.sd)
```

Now we run the analysis and gather results.
```{r, eval=FALSE}
handle.norm.root <- ratematrixMCMC(data=dat, phy=phy, prior=norm.prior, start="prior_sample"
                                   , gen=200000, outname="normal_root_prior", prop=c(0.1,0.9) )
```

```{r, echo=FALSE}
load( system.file("extdata", "norm.root.RData", package = "ratematrix") )
```
```{r, eval=2}
post.norm.root <- readMCMC(handle=handle.norm.root)
checkConvergence(post.norm.root)
```

We should check again the prior and the posterior.
```{r, fig.height=4, fig.width=6}
plotPrior(handle=handle.norm.root, root=TRUE)
```

```{r, fig.height=4, fig.width=6}
plotRootValue(post.norm.root, vline.values = c(5,10), vline.color = c("red","red"))
```


Note how the prior distribution is away from the true parameter values of the model. Now compare the plot for the prior distribution with the plot for the posterior. Pay attention to the x axes of the two plots. The red lines show the true parameter values.

The posterior distributions are not centered in the true parameter values for the model. The true value for trait_1 is not within the 95% HPD of the posterior distribution whereas trait_2 is. Also note that the true value for trait_1 is not within a high density of the prior whereas the true value for trait_2 is:
```{r}
## Check the summary and quartiles for the prior distributions.
## Prior for trait 1:
summary( rnorm(1000, 0, 1) )
## Prior for trait 2:
summary( rnorm(1000, 15, 2) )
```

The true value of trait_1 is way off the prior distribution. For trait_2 the true value is within the first quartile. Thus, the posterior distribution was updated in the direction of the true parameter value, but the effect of the prior was strong and biased the results.

Keep in mind that this is an extreme example to show the effect of an informative and wrong prior. However, this same effect can improve an analysis if the prior is properly created by using external data (such as fossils) or bounded on realistic parameter values for the model.

## Priors on the evolutionary rate matrix

While the vector of root values represents the starting point for the multivariate Brownian-motion process walking along the branches of the tree, the evolutionary rate matrix (**R**) is the variance-covariance matrix of such process. Here we can set priors for both the rates of evolution for each trait and their evolutionary covariances.

External information for the evolutionary covariances among traits can be results from studies of character correlations within or among populations or even knowledge about the underlying genetic architecture of the traits. It is possible to set informative (or uninformative) priors independently for the structure of evolutionary correlation among the traits and the rates of evolution of each trait. This flexibility is a result of the sampling strategy used in the MCMC.

In this part of the tutorial we will set a uninformative prior and compare the results with an informative prior. For simplicity, we will use the same data set and trees used in the previous section.

### Uniformative priors on the evolutionary correlation

First we will set a uninformative prior for the evolutionary correlation among traits. This analysis is identical to the first analysis conducted in this tutorial. So we will use the same results.

This uninformative prior on the evolutionary covariances is a marginally uniform prior. In other words, the correlation among each two traits in the data has a uniform distribution when integrated over the uncertainty in all other elements of the **R** matrix.

First plot the prior for the entire **R** matrix:
```{r, fig.height=4, fig.width=4}
plotPrior(handle.unif.root, n = 10000, root = FALSE, set.xlim=c(-10,10), alphaEll=0.5)
```

Now, since this prior distribution is composed by a correlation matrix that describe the structure of evolutionary correlation among traits and a vector of variances (the rates of evolution for each trait), we can decompose the matrices plotted in the last figure and create independent plots.

For this we need first to take some samples from the prior distribution. The `samplePrior` function can be used to take samples from a prior distribution. Options allow for generating **R** matrices from the sample or output the correlation matrix and vector of standard deviations independently. We will use the later option, so that we can prepare independent plots.
```{r, fig.height=4, fig.width=4, fig.show="hold"}
ss <- samplePrior(n=1000, prior=unif.prior, sample.sd = TRUE, rebuild.R = FALSE)
corr <- sapply(ss$matrix, function(x) cov2cor(x)[1,2] )
hist( corr, main="Correlation between traits")
hist( ss$sd[,1], main="Standard deviation - trait 1")
hist( ss$sd[,2], main="Standard deviation - trait 2")
```

Note from these plots that the prior on the correlation is uniform and the standard deviations have a log-normal prior. It is difficult to see from the plot of the whole **R** matrix that the correlations are uniformly distributed, but this is made clear by decomposing the variance-covariance matrix.

We already performed the analysis using this data and prior. So we will just plot the posterior distribution for the **R** matrix:
```{r, fig.height=4, fig.width=4}
plotRatematrix(chain=post.unif.root, set.leg = c("trait_1", "trait_2"), point.matrix = list(R)
               , point.color = "red", point.wd = 1.5)
```

Here note that the red line show the **R** matrix used to generate the data. The posterior distribution in this case is nicely congruent with the true parameter value.

### Using informative prior distributions on the structure of evolutionary correlation among traits

Here we have external information about the pattern of evolutionary integration among traits. Perhaps we know that traits show positive correlation, negative correlation or we have a strong prior that no correlation should be observed.

Note that I used a log-normal prior on the standard deviations of the previous analyses. Such prior puts more weight towards smaller values for the rates of evolution of the traits. This follows the notion that values for this parameter are usually not very large. Something between 0 and 10, but varying in function of the depth of the phylogeny. On the other hand, the marginally uniform prior set a uniform prior on the evolutionary correlation among the traits, so negative, positive and no correlation have the same weight (probability).

Here we will set the prior such that most of the density is centered in no correlation. Note that it is important to set the option 'unif.corr' to FALSE in order to input different values for parameters 'Sigma' and 'nu'.
```{r}
## Create a matrix with the bounds for the uniform prior. 
## Here will use the max and min of the tip data as bounds.
par.mu <- rbind( ceiling( range(dat[,1]) ), ceiling( range(dat[,2]) ) )
## Using a lognormal prior on the standard deviations, with log(mean)=0 and log(sd)=1.5.
par.sd <- c(0,1.5)
## Sigma is a scale matrix. This is equivalent to the mean of a inverse-Wishart.
## An identity matrix will center the distribution on 0 correlation.
Sigma <- rbind( c(1, 0),
                c(0, 1) )
## nu is the equivalent of the variance of this distribution. But here large values mean most of the
##    samples will be close to the Sigma matrix whereas small values (min = number of traits +1) will
##    result in a more spread distribution.
nu <- 50 ## This will constrain the distribution around the Sigma matrix.
corr.prior <- makePrior(r = 2, p = 1, den.mu = "unif", par.mu = par.mu, den.sd = "lnorm"
                        , par.sd = par.sd, unif.corr = FALSE, Sigma = Sigma, nu = nu)
```

We can take samples of this prior. Here separating the standard deviations from the correlation matrix.
```{r, fig.height=4, fig.width=4, fig.show="hold"}
ss.corr <- samplePrior(n = 1000, prior=corr.prior, sample.sd = TRUE, rebuild.R = FALSE)
corr.p <- sapply(ss.corr$matrix, function(x) cov2cor(x)[1,2] )
hist( corr.p, main="Correlation between traits")
hist( ss.corr$sd[,1], main="Standard deviation - trait 1")
hist( ss.corr$sd[,2], main="Standard deviation - trait 2")
```

Notice how the distribution for the standard deviations has not changed, but the prior on the correlation is not centered on the zero value. Also pay attention to the x axis on the plot, the true value of the correlation is:
```{r}
cov2cor(R)[1,2]
```

Now take samples of **R** matrices from the prior. This time not separating into different elements. To do this we just need to pass the prior samples to the plotting function. The plotting function will take care of rebuilding the **R** matrix from the vector of standard deviations and the correlation matrix.
```{r, fig.height=4, fig.width=4, fig.show="hold"}
plotRatematrix(ss.corr, set.xlim = c(-10,10), show.zero = TRUE)
```

Comparing this prior distribution with the previous analysis it is possible to see how the covariance term is much more tightly distributed around 0.

Now we can set and run the analysis with this prior, then check convergence and plot the posterior distribution.
```{r, echo=FALSE}
load( system.file("extdata", "corr.zero.RData", package = "ratematrix") )
```
```{r, fig.height=4, fig.width=4, eval=c(3,4)}
handle.corr.zero <- ratematrixMCMC(data=dat, phy=phy, prior=corr.prior, start="prior_sample"
                                   , gen=200000, outname="corr_zero_prior", prop=c(0.1,0.9) )
post.corr.zero <- readMCMC(handle=handle.corr.zero)
checkConvergence(post.corr.zero)
plotRatematrix(post.corr.zero, point.matrix = list(R), point.color = "red", point.wd = 1.5
               , show.zero = TRUE)
```

Now we can see a result that is similar to when we set a informative prior to the vector of root values. The posterior distribution for the evolutionary covariance among traits is not centered in the true parameter value whereas it was in the previous analysis with the marginally uniform prior. The bias is also predictable, the posterior distribution has shifted towards the zero value.

> "And a lean, silent figure slowly fades into the gathering darkness, aware at last that in this world, with great power there must also come -- great responsibility!"
(Stan Lee and Steve Ditko, 1962. Amazing Fantasy #15)